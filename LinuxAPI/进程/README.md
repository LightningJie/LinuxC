# 进程
## 进程标识符
Pid=0 ：交换进程（空闲进程）
Pid=1：init进程（系统初始化）
getpid函数：获取自认进程标识符
getppid函数：获取父进程的进程标识符
~~~c
#include <sys/types.h>
#include <unistd.h>
pid_t getpid(void);
pid_t getppid(void);
~~~
## C程序的存储空间是如何分配的？
1. 代码段（Text Segment）
用途：存储程序的可执行代码（即机器指令）。
特点：
代码段是只读的，因为它不需要在运行时修改。
它通常被共享，多个进程可以共享同一份代码段，以节省内存。
代码段的大小在程序编译时确定，运行时不会改变。
2. 数据段（Data Segment）
用途：存储程序的全局变量和静态变量。
特点：
数据段分为初始化数据区和未初始化数据区（BSS段）。
初始化数据区：存储已初始化的全局变量和静态变量。
BSS段：存储未初始化的全局变量和静态变量。这些变量在程序启动时自动初始化为零。
数据段的大小在程序编译时确定，但其内容可以在运行时修改。
3. 堆（Heap）
用途：动态分配的内存区域，主要用于存储动态分配的数据（如通过 malloc、calloc、realloc 等分配的内存）。
特点：
堆的大小在运行时动态变化，由程序员通过内存分配函数管理。
堆内存的分配和释放需要手动管理，否则可能导致内存泄漏或内存溢出。
堆内存通常由操作系统管理，分配效率可能较低。
4. 栈（Stack）
用途：存储函数调用时的局部变量、函数参数、返回地址和调用上下文。
特点：
栈的大小在运行时动态变化，但其增长和释放是自动的（通过函数调用和返回）。
栈的分配和释放效率高，因为它是连续的内存区域，遵循后进先出（LIFO）原则。
栈的大小通常有限制（如几MB），超出限制可能导致栈溢出（Stack Overflow）。
5. 常量区（Constant Segment）
用途：存储程序中的常量数据，如字符串常量、数字常量等。
特点：
常量区是只读的，其内容在程序运行时不能修改。
常量区的大小在编译时确定，运行时不会改变。

~~~c
+---------------------------+  <- 高地址
|                           |
|    堆 (Heap)              |
|                           |
+---------------------------+
|                           |
|    栈 (Stack)             |
|                           |
+---------------------------+
|                           |
|   数据段 (Data Segment)   |
|   包括初始化数据区和BSS区  |
+---------------------------+
|                           |
|   代码段 (Text Segment)   |
|                           |
+---------------------------+  <- 低地址
~~~

## 进程创建的过程
1. 父进程调用 fork()
父进程通过调用 fork() 系统调用请求操作系统创建一个新进程。
2. 操作系统分配新的进程 ID（PID）
操作系统为新创建的子进程分配一个唯一的进程 ID（PID）。这个 PID 在整个系统中是唯一的，用于标识和管理进程。
3. 复制父进程的上下文
进程表项：操作系统在进程表中为子进程创建一个新的表项，复制父进程的大部分信息（如进程状态、优先级等）。
内存空间：子进程获得父进程数据空间、堆和栈的副本。在某些实现中（如 Linux 的 fork()），操作系统使用“写时复制”（Copy-On-Write, COW）技术来优化内存使用。这意味着父子进程共享相同的物理内存页面，直到其中一个进程尝试修改页面内容时，操作系统才会创建该页面的副本。
文件描述符：子进程继承父进程打开的文件描述符，但每个文件描述符在父子进程中是独立的。对文件描述符的操作（如读写）不会相互影响。
信号处理：子进程继承父进程的信号处理设置，但子进程不会继承父进程捕获的信号。
4. 设置子进程的初始状态
子进程的程序计数器（PC）被设置为父进程调用 fork() 时的值，因此子进程从父进程调用 fork() 的下一条指令开始执行。
子进程的返回值被设置为 0，而父进程的返回值是子进程的 PID。
5. 父进程和子进程继续执行
父进程和子进程从 fork() 调用的下一条指令开始执行。
父进程可以通过返回的 PID 来识别子进程，并可以使用系统调用（如 wait()）来等待子进程结束。
子进程通常会执行与父进程不同的代码路径，例如通过检查 fork() 的返回值来决定执行不同的任务

## fork()函数的返回值

**对于父进程**：fork() 函数返回新创建的子进程的进程 ID（PID）。这是一个正整数，可以用来在父进程中识别和控制子进程。
**对于子进程**：fork() 函数返回 **0**。这使得子进程可以识别自己是子进程，并且可以执行与父进程不同的代码路径。
**子进程的执行起点：**
**子进程从 fork() 的返回点开始执行**,这意味着子进程和父进程在 fork() 的返回点之后的代码路径是相同的，但它们的返回值不同。

## 创建新进程的应用场景
1. 并行处理
通过创建多个子进程，可以实现任务的并行处理，从而提高程序的执行效率。例如，在数据处理任务中，可以将数据分割成多个部分，每个子进程处理一部分数据，最后汇总结果。
2. 服务器和客户端模型
在服务器程序中，每当接收到客户端请求时，可以使用 fork() 创建一个子进程来独立处理该请求。这样可以实现高并发处理，避免多个客户端请求相互干扰。
3. 任务调度
操作系统通过创建新进程来分配和管理任务。例如，init 进程是系统启动时创建的第一个进程，其他所有进程都是通过 init 进程的 fork() 调用创建的。
4. 网络服务器
网络服务器通常会为每个客户端连接创建一个子进程，以便独立处理客户端请求。这种方式可以提高服务器的并发能力和响应速度。
5. 守护进程
守护进程通常在后台运行，用于执行特定的任务，如日志记录、监控系统状态等。守护进程可以通过 fork() 创建子进程来实现其功能。
6. 程序执行
在 Linux 系统中，fork() 和 exec() 结合使用可以实现程序的动态加载和执行。子进程通过 exec() 替换当前进程映像，加载并运行新的程序。
7. 资源管理
在某些情况下，创建新进程可以更好地管理资源。例如，子进程可以独立管理内存、文件描述符等资源，避免资源冲突。
8. 测试和调试
在软件开发中，创建新进程可以用于测试程序的并发性和稳定性。通过模拟多进程环境，可以更好地发现和修复潜在的并发问题。

## vfork和fork的区别

- 区别一：
vfork 直接使用父进程存储空间，不拷贝。
- 区别二：
vfork保证子进程先运行,当子进程调用exit退出后，父进程才执行。

## 进程退出
### 正常退出

1. Main函数调用return
2. 进程调用exit(),标准c库
3. 进程调用_exit()或者_Exit()，属于系统调用
补充：
4. 进程最后一个线程返回
5. 最后一个线程调用pthread_exit

### 异常退出
1. 调用abort函数
2. 当进程收到某些信号时，如ctrl+C
3. 最后一个线程对取消（cancellation）请求做出响应

### c库exit和系统调用_exit原型
~~~c
#include <stdlib.h>
void exit(int status);
~~~
exit是对_Exit 和_exit的封装，exit会刷新缓冲区，如果没有exit，进程内的数据就会被破坏。
~~~c
#include <stdlib.h>
void _Exit(int status);
~~~
~~~c
#include <unistd.h>
void _exit(int status);
~~~

## 等待子进程退出
父进程等待子进程的退出，并收集子进程退出的状态
子进程退出状态不被收集，变成僵尸进程（Zombie）
### 原型
系统调用
~~~c
#include <sys/types.h>
#include <sys/wait.h>

pid_t wait(int *wstatus);

pid_t waitpid(pid_t pid, int *wstatus, int options);

int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options);
~~~
- status参数是一个整型数指针
非空：子进程退出状态放在它所指向的地址中。
空（NULL）：不关心退出状态
- pid：指定要等待的子进程的 PID。
如果等于-1，表示等待任意一个子进程结束，与 wait 函数的行为相同
如果为小于-1，等待属于特定进程组（由 pid 的绝对值指定）的任意一个子进程结束。
如果为 0，表示等待同一进程组的任意子进程。
如果为正整数，表示等待特定 PID 的子进程。
- options：控制等待行为的选项，可以是以下值的组合：
WNOHANG：非阻塞调用，如果子进程尚未结束，则立即返回。
WUNTRACED：报告停止（挂起）的子进程。
WCONTINUED：当被停止的子进程恢复时，返回它的状态。当被停止的子进程收到 SIGCONT 信号并重新开始执行时，报告其状态
C库
~~~c
#include <sys/wait.h>

pid_t wait(int *stat_loc);
pid_t waitpid(pid_t pid, int *stat_loc, int options);
~~~
### wait和waitpid的区别
1. wait 函数
wait 函数用于等待任意一个子进程结束。
**特点：**
阻塞调用：父进程会阻塞，直到任一个子进程结束。
无法指定等待特定的子进程。
只能使用一次，即在调用后，不能再用来等待同一个子进程。
2. waitpid 函数
waitpid 函数提供了更多的控制，允许父进程等待特定的子进程结束，并允许非阻塞操作。
**返回值：**
成功时返回结束的子进程的 PID。
如果设置了 WNOHANG 且没有子进程结束，则返回 0。
失败时返回 -1，并设置 errno 以指示错误。
**特点：**
可以指定等待特定的子进程。
支持非阻塞调用（通过 WNOHANG 选项）。
可以多次使用，即在调用后，仍然可以再次用来等待同一个子进程。
- 总结
  wait会父进程会阻塞等待子进程运行完之后，再返回执行
  waitpid 会父进程子进程同时执行，等子进程结束了，只剩父进程执行了。 
  waitpid 虽然会收集子进程的退出状态，但是依然会产生僵尸进程。


## 检查由 wait 和 waitpid 函数返回的子进程状态的宏
1. **WIFEXITED(status)**
功能：检查子进程是否正常终止。
参数：status，由 wait 或 waitpid 函数返回的状态值。
返回值：如果子进程正常终止，则返回真（非零）；否则返回假（零）。
用法：如果 WIFEXITED 返回真，可以使用 `WEXITSTATUS(status) `宏获取子进程的退出状态（即 exit、_exit 或 _Exit 函数调用时传递的参数值）。
1. **WIFSIGNALED(status)**
功能：检查子进程是否因接收到信号而异常终止。
参数：status，由 wait 或 waitpid 函数返回的状态值。
返回值：如果子进程因信号异常终止，则返回真；否则返回假。
用法：如果 WIFSIGNALED 返回真，可以使用 WTERMSIG(status) 宏获取导致子进程终止的信号编号。
补充：某些系统可能还定义了 WCOREDUMP(status) 宏，用于检查子进程是否生成了核心转储文件。
1. **WIFSTOPPED(status)**
功能：检查子进程是否当前处于暂停状态。
参数：status，由 wait 或 waitpid 函数返回的状态值。
返回值：如果子进程处于暂停状态，则返回真；否则返回假。
用法：如果 WIFSTOPPED 返回真，可以使用 WSTOPSIG(status) 宏获取导致子进程暂停的信号编号。
1. **WIFCONTINUED(status)**
功能：检查在作业控制暂停后是否已经继续的子进程返回了状态。
参数：status，由 waitpid 函数返回的状态值（注意：这个宏仅适用于 waitpid）。
返回值：如果子进程已经从暂停状态继续，则返回真；否则返回假。
补充：这是 POSIX.1 的 XSI 扩展，仅用于 waitpid。

## 孤儿进程
父进程如果不等待子进程退出，在子进程之前就结束了自己的“生命”，此时子进程叫做孤儿进程
Linux避免系统存在过多孤儿进程，init进程收留孤儿进程，变成孤儿进程的父进程

## exec族函数
fork函数创建新进程后，经常会在新进程中调用exec函数去执行另外一个程序。当进程调用exec函数时，该进程被完全替换为新程序。因为调用exec函数并不创建新进程，所以前后进程的ID并没有改变

- 功能：
在调用进程内部执行一个可执行文件。可执行文件既可以是二进制文件，也可以是任何Linux下可执行的脚本文件。

- 函数族：
  exec函数族分别是：execl, execlp, execle, execv, execvp, execvpe
~~~c
#include <unistd.h>
extern char **environ;

int execl(const char *path, const char *arg, ...);
int execlp(const char *file, const char *arg, ...);
int execle(const char *path, const char *arg,..., char * const envp[]);
int execv(const char *path, char *const argv[]);
int execvp(const char *file, char *const argv[]);
int execvpe(const char *file, char *const argv[],char *const envp[]);
~~~

- 返回值：
exec函数族的函数执行成功后不会返回，调用失败时，会设置errno并返回-1，然后从原程序的调用点接着往下执行。

- 参数说明：
`path`：可执行文件的路径名字
`arg`：可执行程序所带的参数，第一个参数为可执行文件名字，没有带路径且arg必须以NULL结束
`file`：如果参数file中包含/，则就将其视为路径名，否则就按 PATH环境变量，在它所指定的各目录中搜寻可执行文件。

exec族函数参数极难记忆和分辨，函数名中的字符会给我们一些帮助：
l : 使用参数列表
p：使用文件名，并从PATH环境进行寻找可执行文件
v：应先构造一个指向各参数的指针数组，然后将该数组的地址作为这些函数的参数。
e：多了envp[]数组，使用新的环境变量代替调用进程的环境变量

- 补充perror("why:")
perror 是一个库函数，用于将 errno 变量中存储的错误代码转换为人类可读的字符串，并打印到标准错误输出（stderr）。它接受一个可选的字符串参数，该字符串会在错误消息前打印，通常用于描述出错的函数或操作。 

### excel 样例程序
以进程中途执行ls为例
~~~c
//文件execl.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
//函数原型：int execl(const char *path, const char *arg, ...);

int main(void)
{
    printf("before execl\n");
    if(execl("/user/bin/ls","ls","-l",NULL) == -1)
    {
        printf("execl failed!\n");      
    }
    printf("after execl\n");
    return 0;
}
~~~
可以看到 excel的第一个参数是路径，这样需要频繁的whereis指令查询想要的程序路径，比较麻烦。而excelp没有这个问题，exaclp函数带p，所以能通过**环境变量PATH**查找到可执行文件ls

~~~c
execlp("ls","ls","-l",NULL)
~~~
execvp 就是在execlp基础上，改成了参数列表传参。
~~~c
char *argv[]={"ls",NULL};
if(execvp("ls",argv) == -1)
~~~

### 环境变量
gcc生成的可执行文件（例如a.out 或者自定义名字）在实际使用中，需要增加`./`才能使用，而且只能在本路径下去使用，不能直接使用。
可以pwd当前路径然后加入环境变量里
~~~bash
export PATH=$PATH:可执行文件路径
~~~
当在终端中输入 ls 命令时，系统会依次在 /usr/bin、/bin、/usr/local/bin 和 /home/user/bin 等环境变量里的目录中查找名为 ls 的可执行文件。如果找到，就会执行它。
如果没有设置 PATH，或者可执行文件不在 PATH 中的目录里，需要使用完整路径来


## system函数
和execl函数相似，运行新的可执行文件
system()函数的返回值如下： 
成功，则返回进程的状态值； 
当sh不能执行时，返回127； 
失败返回-1； 

~~~c
#include <stdlib.h>
int system(const char *command);
~~~

## popen函数
[博客详解](https://www.cnblogs.com/leijiangtao/p/4051387.html
)
~~~c
#include <stdio.h>
FILE *popen(const char *command, const char *type);
int pclose(FILE *stream);
~~~


