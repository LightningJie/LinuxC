

# 1. static/const/constexpr

在 C++ 中，`static`、`const` 和 `constexpr` 是三个不同的关键字，各自有不同的语义和用途，主要区别体现在**作用域、存储周期、常量性**和**编译期 / 运行期行为**上。

1. `static`：控制存储周期、可见性和链接性

`static` 的核心作用是**调整变量 / 函数的存储方式、可见范围或类成员的共享性**，不直接关联 “常量性”。其行为因使用场景而异：

- **修饰全局变量 / 函数**：
  限制其**链接性为内部链接**（仅当前文件可见），避免跨文件重定义。存储在全局数据区，程序生命周期内唯一存在。

  ```cpp
  // file1.cpp
  static int g_val = 10; // 仅file1.cpp可见
  static void func() {}  // 仅file1.cpp可见
  ```

- **修饰局部变量**：
  改变其**存储周期为全局生命周期**（程序启动时初始化，结束时销毁），但作用域仍限于局部（函数 / 代码块内）。每次进入作用域时不会重新初始化。

  ```cpp
  void count() {
      static int cnt = 0; // 仅初始化一次
      cnt++; 
      cout << cnt << endl; // 每次调用输出递增的值
  }
  ```

- **修饰类成员变量 / 函数**：

  - 静态成员变量：属于**类本身**（而非某个实例），所有对象共享同一份数据，需在类外单独定义。
  - 静态成员函数：无 `this` 指针，只能访问静态成员，可通过类名直接调用（无需实例）。

  ```cpp
  class A {
  public:
      static int x; // 类共享的变量
      static void print() { cout << x << endl; } // 静态成员函数
  };
  int A::x = 0; // 类外定义
  ```

2. `const`：声明 “只读” 属性（运行期或编译期常量）

`const` 的核心是**限制变量 / 对象 “不可被修改”**，强调 “只读性”，但不一定是 “编译期可知” 的常量。

- **修饰普通变量**：
  变量初始化后不可修改，其值可以是**运行期确定**（如由函数返回值初始化）。

  ```cpp
  const int a = 10; // 编译期常量（可用于数组大小等）
  int b = 20;
  const int c = b;  // 运行期常量（值由b决定，不可修改）
  ```

- **修饰指针**：
  需区分 “指向常量的指针” 和 “指针常量”：

  ```cpp
  const int* p1; // p1指向的内容不可改（指针可变）
  int* const p2; // p2本身不可改（指向的内容可变）
  ```

- **修饰类成员**：

  - `const` 成员变量：每个实例单独拥有，必须在构造函数初始化列表中初始化，不可修改。
  - `const` 成员函数：保证函数内部不修改非静态成员变量，也不能调用非 `const` 成员函数。

  ```cpp
  class A {
  public:
      const int x; // 实例的常量成员
      A(int val) : x(val) {} // 必须在初始化列表初始化
      void print() const { // const成员函数
          // x = 10; 错误：不能修改成员变量
      }
  };
  ```

3. `constexpr`：编译期可计算的常量 / 函数（C++11 起）

`constexpr` 的核心是**强调 “编译期可求值”**，用于定义编译期常量或可在编译期执行的函数，以提升性能（避免运行期计算）。

- **修饰变量**：
  变量必须是**编译期可知的常量**（值在编译时确定），且隐含 `const` 属性（不可修改）。

  ```cpp
  constexpr int a = 10; // 编译期常量
  constexpr int b = a + 5; // 编译期计算（结果15）
  
  int c = 20;
  // constexpr int d = c; 错误：c是运行期变量，无法编译期确定
  ```

- **修饰函数**：
  函数的返回值可在**编译期计算**（当参数为编译期常量时），函数体必须是简单的表达式（不能有复杂控制流，如循环需在 C++14 后支持）。

  ```cpp
  // 编译期可计算的函数
  constexpr int add(int x, int y) {
      return x + y;
  }
  
  constexpr int res = add(3, 4); // 编译期计算（结果7）
  int a = 5;
  int res2 = add(a, 4); // 运行期计算（a是变量）
  ```

  - 当传入**编译期常量**（如 `add(3, 4)` 中的 `3` 和 `4`），**函数会在编译期计算**，返回值也是编译期常量（可用于需要编译期常量的场景，如数组大小）。
  - 当传入**运行期变量**（如 `add(a, 4)` 中的 `a`），**函数会退化为普通函数**，在运行期计算，返回值是普通变量。

- **修饰类构造函数**：
  允许创建编译期的类实例（需满足构造函数体内无副作用，成员初始化均为编译期常量）。

  ```cpp
  class Point {
  private:
      int x;
      int y;
  public:
      // constexpr构造函数：编译期可执行
      constexpr Point(int a, int b) : x(a), y(b) {}  // 仅初始化成员，无其他操作
  
      // constexpr成员函数：返回编译期可计算的结果
      constexpr int getX() const { return x; }
      constexpr int getY() const { return y; }
  };
  
  int main() {
      // 1. 编译期创建对象（使用constexpr构造函数）
      constexpr Point p1(10, 20);  // 编译期完成初始化
      static_assert(p1.getX() == 10, "x值错误");  // 编译期断言（验证编译期计算结果）
  
      // 2. 运行期创建对象（和普通构造函数一样使用）
      int a = 30;  // 运行期变量
      Point p2(a, 40);  // 运行期初始化（合法，constexpr构造函数兼容运行期场景）
  
      return 0;
  }
  ```

  

核心区别总结

| 维度     | `static`                                 | `const`                                       | `constexpr`                              |
| -------- | ---------------------------------------- | --------------------------------------------- | ---------------------------------------- |
| 核心作用 | 控制存储周期、可见性、类共享性           | 声明 “只读”（不可修改）                       | 声明 “编译期可计算”（常量 / 函数）       |
| 常量性   | 不保证常量性（变量可修改）               | 保证只读（不可修改）                          | 隐含 const（不可修改）                   |
| 求值时机 | 无要求（运行期为主）                     | 可运行期或编译期                              | 必须编译期可求值（变量）                 |
| 典型场景 | 全局变量封装、局部变量持久化、类共享成员 | 运行期常量、只读参数 / 返回值、const 成员函数 | 编译期常量（如数组大小）、编译期计算函数 |

简单来说：

- `static` 管 “存储和可见性”，
- `const` 管 “不可修改”，
- `constexpr` 管 “编译期可算”。

# 2.auto

- 当变量不是指针或者引用类型时，推导的结果中不会保留const、volatile关键字

- 当变量是指针或者引用类型时，推导的结果中会保留const、volatile关键字

# 3.chrono库

C++11 引入的 `<chrono>` 库是一个强大的时间处理工具库，用于表示、操作和测量时间间隔。它提供了类型安全、高精度的计时功能，避免了传统 C 风格时间函数（如 `time()` 或 `gettimeofday()`）的易错性和平台依赖性。以下是 `<chrono>` 库的核心组件和用法详解：

------

**1. 核心组件**

**(1) 时间点（`time_point`）**

表示一个具体的时间点（如“2023年1月1日 12:00:00”），由一个时钟（`clock`）和一个时间间隔（`duration`）组成：

```cpp
#include <chrono>
using namespace std::chrono;
 
// 系统时钟的当前时间点
auto now = system_clock::now();
```

**(2) 时间间隔（`duration`）**

表示两个时间点之间的时长，支持多种单位（秒、毫秒、微秒等）：

```cpp
duration<int> seconds_3(3);       // 3秒（整数）
duration<double, ratio<60>> minutes_1(1); // 1分钟（60秒，双精度）
 
// 预定义类型（推荐使用）
auto ms = milliseconds(500);     // 500毫秒
auto us = microseconds(1000);    // 1000微秒
auto s = seconds(2);             // 2秒
```

**(3) 时钟（`clock`）**

提供时间点的获取方式，C++11 定义了三种时钟：

- **`system_clock`**：系统实时时间（可调整，用于日历时间）。
- **`steady_clock`**：单调时钟（不受系统时间调整影响，适合计时）。
- **`high_resolution_clock`**：当前平台最高精度的时钟（可能是 `system_clock` 或 `steady_clock` 的别名）。

```cpp
auto start = steady_clock::now(); // 开始计时
// ...执行某些操作...
auto end = steady_clock::now();   // 结束计时
auto elapsed = end - start;       // 时间间隔（duration类型）
```

------

**2. 常用操作**

**(1) 时间间隔计算**

```cpp
auto start = high_resolution_clock::now();
// 模拟耗时操作
for (int i = 0; i < 1000000; ++i) {}
auto end = high_resolution_clock::now();
 
// 计算耗时（转换为毫秒）
auto duration = duration_cast<milliseconds>(end - start);
cout << "耗时: " << duration.count() << " 毫秒" << endl;
```

**(2) 时间点转换**

将 `time_point` 转换为 `time_t`（用于 `ctime` 函数）：

```cpp
auto now = system_clock::now();
time_t now_time = system_clock::to_time_t(now);
cout << ctime(&now_time); // 输出可读时间字符串
```

**(3) 自定义时间单位**

通过 `ratio` 模板定义任意时间单位：

```cpp
using my_duration = duration<long long, ratio<1, 30>>; // 1/30秒单位
my_duration d(5); // 5 * (1/30) 秒
```

------

**3. 优势**

1. **类型安全**：避免混用不同单位（如误将毫秒加到秒上）。
2. **高精度**：支持纳秒级精度（取决于硬件）。
3. **可读性**：直接使用 `seconds`、`milliseconds` 等预定义类型。
4. **跨平台**：统一接口，隐藏系统差异。

------

**4. 完整示例**

```cpp
#include <iostream>
#include <chrono>
#include <thread> // 用于 sleep_for
 
using namespace std::chrono;
 
int main() {
    
    using one_second = std::ratio<1, 1>;       // 1/1 秒
	using half_second = std::ratio<1, 2>;      // 1/2 秒
	using two_seconds = std::ratio<2, 1>;      // 2/1 秒
	using milli = std::ratio<1, 1000>;         // 1/1000 秒（毫秒）
	using micro = std::ratio<1, 1000000>;      // 1/1000000 秒（微秒）
    // 计时示例
    auto start = steady_clock::now();
    std::this_thread::sleep_for(seconds(1)); // 休眠1秒
    auto end = steady_clock::now();
 
    auto elapsed = duration_cast<milliseconds>(end - start);
    std::cout << "实际耗时: " << elapsed.count() << " 毫秒" << std::endl;
 
    // 时间点转换
    auto now = system_clock::now();
    std::time_t now_time = system_clock::to_time_t(now);
    std::cout << "当前时间: " << std::ctime(&now_time);
 
    return 0;
}
```

------

**5. 注意事项**

- **`duration_cast` 的必要性**：直接输出 `duration` 可能显示为编译器定义的单位（如 `[0/1000]` 毫秒），需显式转换。
- 时钟选择：
  - 测量耗时用 `steady_clock`（避免系统时间调整影响）。
  - 获取日历时间用 `system_clock`。
- **C++20 扩展**：新增了 `calendar` 和 `timezone` 支持，进一步简化日期处理。

通过 `<chrono>` 库，C++ 终于拥有了现代、安全的时间处理能力，极大简化了计时和日期相关的编程任务。

# 4.using

在 C++ 中，`using` 关键字主要有两种用途：**类型别名**（替代 `typedef`）和**命名空间别名**。以下是详细说明和示例：

------

**1. 类型别名（Type Alias）**

`using` 可以为现有类型创建别名，比传统的 `typedef` 更直观，尤其适用于复杂类型（如模板、函数指针等）。

**基本语法**

```cpp
using NewTypeName = ExistingType;
```

**示例**

**(1) 简单类型别名**

```cpp
#include <iostream>
 
// 为 int 起别名
using MyInt = int;
 
int main() {
    MyInt x = 10;  // 等价于 int x = 10;
    std::cout << x << std::endl;
    return 0;
}
```

**(2) 复杂类型别名**

```cpp
#include <vector>
#include <string>
 
// 为 std::vector<std::string> 起别名
using StringVector = std::vector<std::string>;
 
int main() {
    StringVector names = {"Alice", "Bob", "Charlie"};
    for (const auto& name : names) {
        std::cout << name << std::endl;
    }
    return 0;
}
```

==**(3) 函数指针别名**==

```cpp
// 为函数指针类型起别名
using Callback = void (*)(int);
 
void PrintNumber(int num) {
    std::cout << "Number: " << num << std::endl;
}
 
int main() {
    Callback func = PrintNumber;  // func 是指向 PrintNumber 的函数指针
    func(42);                     // 调用函数
    return 0;
}
```

`using Callback = void (*)(int);` 定义了一个**函数指针类型别名**，名为 `Callback`，它表示“指向一个接受 `int` 参数且返回 `void` 的函数的指针

**(4) 模板别名（C++11 起）**

```cpp
#include <map>
#include <string>
 
// 为模板实例化起别名
template <typename T>
using StringMap = std::map<std::string, T>;
 
int main() {
    StringMap<int> ageMap = {{"Alice", 25}, {"Bob", 30}};
    for (const auto& pair : ageMap) {
        std::cout << pair.first << ": " << pair.second << std::endl;
    }
    return 0;
}
```

------

**2. 命名空间别名（Namespace Alias）**

`using` 可以为冗长的命名空间创建简短的别名，简化代码。

**语法**

```cpp
namespace NewName = LongNamespaceName;
```

**示例**

```cpp
#include <iostream>
 
namespace VeryLongNamespaceName {
    void SayHello() {
        std::cout << "Hello from VeryLongNamespaceName!" << std::endl;
    }
}
 
// 为命名空间起别名
namespace Short = VeryLongNamespaceName;
 
int main() {
    Short::SayHello();  // 等价于 VeryLongNamespaceName::SayHello()
    return 0;
}
```

------

**3. `using` vs `typedef`**

| 特性             | `using`                 | `typedef`               |
| ---------------- | ----------------------- | ----------------------- |
| **语法直观性**   | 更直观（`using A = B`） | 较晦涩（`typedef B A`） |
| **支持模板别名** | 是（C++11 起）          | 否                      |
| **函数指针别名** | 更清晰                  | 较复杂                  |

**示例对比**

**(1) 函数指针**

```cpp
// using（清晰）
using FuncPtr = void (*)(int);
 
// typedef（晦涩）
typedef void (*FuncPtr)(int);
```

**(2) 模板别名**

```cpp
// using（支持模板）
template <typename T>
using Vec = std::vector<T>;
 
// typedef（无法直接实现模板别名）
// 需要借助 struct 包装（C++03 风格）
template <typename T>
struct Vec {
    typedef std::vector<T> type;
};
Vec<int>::type v;  // 使用麻烦
```

------

# 5.模板

一、模板的核心概念

1. **泛型编程**：模板的核心思想是泛型编程，即通过参数化类型来实现代码的通用性。使用模板，你可以为不同的数据类型编写相同的算法或数据结构，而无需为每种类型单独编写代码。
2. **编译期机制**：模板在编译时被实例化，编译器会根据模板参数生成具体的代码。这意味着模板不会增加运行时的开销，但可能会增加编译时间和二进制文件的大小。
3. **类型安全**：模板在编译时进行类型检查，这有助于减少运行时错误。

二、函数模板

函数模板用于创建通用的函数，可以处理不同类型的参数。

1. **定义语法**：

```cpp
template <typename T>  // 或 template <class T>
返回类型 函数名(参数列表) {
    // 函数体
}
```

- `template`：关键字，用于声明模板。
- `typename T`：模板形参，表示一个未知的类型。`class T` 与 `typename T` 等价。
- 函数体：可以使用模板形参 `T` 来定义变量、参数和返回值类型。

1. **使用示例**：

```cpp
#include <iostream>
 
// 函数模板：交换两个变量的值
template <typename T>
void swapValues(T& a, T& b) {
    T temp = a;
    a = b;
    b = temp;
}
 
int main() {
    int x = 10, y = 20;
    double m = 1.1, n = 2.2;
 
    swapValues(x, y);  // 自动推导为 swapValues<int>
    swapValues(m, n);  // 自动推导为 swapValues<double>
 
    std::cout << "x: " << x << ", y: " << y << std::endl;
    std::cout << "m: " << m << ", n: " << n << std::endl;
 
    return 0;
}
```

2. **显式指定类型**：

在某些情况下，你可能需要显式指定模板参数的类型：

```cpp
swapValues<int>(x, y);  // 显式指定为 swapValues<int>
```

3. **多个模板参数**：

函数模板可以包含多个模板参数：

```cpp
template <typename T1, typename T2>
void printValues(T1 a, T2 b) {
    std::cout << "a: " << a << ", b: " << b << std::endl;
}
```

三、类模板

类模板用于创建通用的类，可以处理不同类型的数据成员和成员函数。

1. **定义语法**：

```cpp
template <typename T>
class 类名 {
    // 类定义
};
```

- 类定义：可以使用模板形参 `T` 来定义数据成员和成员函数。

2. **使用示例**：

```cpp
#include <iostream>
 
// 类模板：通用的容器类
template <typename T>
class Container {
private:
    T value;
public:
    Container(T val) : value(val) {}
    T getValue() const { return value; }
    void setValue(T val) { value = val; }
};
 
int main() {
    Container<int> intContainer(42);  // 实例化为 Container<int>
    Container<double> doubleContainer(3.14);  // 实例化为 Container<double>
 
    std::cout << "intContainer: " << intContainer.getValue() << std::endl;
    std::cout << "doubleContainer: " << doubleContainer.getValue() << std::endl;
 
    return 0;
}
```

3. **成员函数定义**：

类模板的成员函数可以在类定义内部定义，也可以在类定义外部定义。在类定义外部定义时，需要使用模板声明：

```cpp
template <typename T>
class Container {
    // ...
    void printValue();  // 声明
};
 
// 类定义外部定义成员函数
template <typename T>
void Container<T>::printValue() {
    std::cout << "Value: " << value << std::endl;
}
```

4. **多个模板参数**：

类模板也可以包含多个模板参数：

```cpp
template <typename T1, typename T2>
class Pair {
private:
    T1 first;
    T2 second;
public:
    Pair(T1 f, T2 s) : first(f), second(s) {}
    // ...
};
```

四、模板的特化

模板特化允许你为特定类型或值提供特定的实现。

1. **完全特化**：

为特定类型提供完整的实现：

```cpp
// 通用模板
template <typename T>
class GenericContainer {
public:
    void print() { std::cout << "GenericContainer<T>" << std::endl; }
};
 
// 完全特化：为 std::string 类型提供特定实现
template <>
class GenericContainer<std::string> {
public:
    void print() { std::cout << "GenericContainer<std::string>" << std::endl; }
};
```

2. **部分特化**（仅类模板支持）：

为部分模板参数提供特定实现：

```cpp
// 通用模板
template <typename T1, typename T2>
class Pair {
public:
    void print() { std::cout << "Pair<T1, T2>" << std::endl; }
};
 
// 部分特化：当 T1 和 T2 为相同类型时
template <typename T>
class Pair<T, T> {
public:
    void print() { std::cout << "Pair<T, T>" << std::endl; }
};
```

五、模板的编译过程

1. **模板声明和定义**：模板的声明和定义通常放在头文件中，因为编译器需要在实例化模板时看到完整的定义。
2. **惰性实例化**：编译器在遇到模板定义时不会立即生成代码，而是在模板被实际使用（实例化）时生成具体的代码。
3. **实例化**：当模板被使用时，编译器根据模板参数生成具体的类或函数定义。

六、模板的优缺点

1. **优点**：

- **代码复用**：减少重复代码，提高开发效率。
- **类型安全**：在编译时进行类型检查，减少运行时错误。
- **性能**：模板在编译时实例化，生成的代码通常不会有运行时的开销。

1. **缺点**：

- **编译时间**：模板的实例化会增加编译时间。
- **代码膨胀**：大量的模板实例化可能导致二进制文件变大。
- **错误信息复杂**：模板错误信息通常比较复杂，难以调试。

# 6.bind

`std::bind` 是 C++11 标准库 `<functional>` 中提供的一个**函数绑定工具**，它的核心作用是 **“包装函数或函数对象，调整其参数列表”**，生成一个新的可调用对象（类似 “函数指针” 但更灵活）。

简单说，`std::bind` 就像一个 “函数适配器”，可以：

- 固定函数的部分参数（提前 “绑定” 一些值）；
- 调整参数的顺序；
- 将类的成员函数与对象绑定（解决成员函数需要 `this` 指针的问题）。

**一、为什么需要 `std::bind`？**

在 C++ 中，函数调用的参数数量和顺序是固定的，但实际开发中经常需要 “灵活调整”：

- 比如 muduo 库的回调函数要求固定的参数格式，但你的业务函数参数可能不同；
- 比如类的成员函数必须通过对象调用（需要 `this` 指针），但库函数可能只接受 “无对象的函数指针”。

`std::bind` 就是为了解决这些 “参数不匹配” 的问题，让不同格式的函数可以 “适配” 到需要的场景中。

**二、`std::bind` 基础用法（3 种核心场景）**

1. 绑定普通函数，固定部分参数

假设有一个加法函数，我们想固定其中一个参数：

```cpp
#include <functional>  // 必须包含此头文件
#include <iostream>

// 普通函数：计算 a + b
int add(int a, int b) {
  return a + b;
}

int main() {
  // 绑定 add 函数，固定第一个参数为 10，第二个参数用 _1 占位（将来传入）
  auto add10 = std::bind(add, 10, std::placeholders::_1);
  
  // 调用绑定后的函数：只需要传入第二个参数
  std::cout << add10(5) << std::endl;  // 等价于 add(10, 5) → 输出 15
  std::cout << add10(20) << std::endl; // 等价于 add(10, 20) → 输出 30
  return 0;
}
```

- `std::placeholders::_1` 是 “占位符”，表示这个位置的参数会在调用时传入（前面已讲过）；
- `auto add10` 是绑定后的 “函数对象”，可以像普通函数一样调用。

2. 绑定类的成员函数（必须指定对象）

类的成员函数需要通过对象调用（隐含 `this` 指针参数），`std::bind` 可以将成员函数与对象绑定：

```cpp
#include <functional>
#include <iostream>

class Calculator {
public:
  // 成员函数：计算 a * b
  int multiply(int a, int b) {
    return a * b;
  }
};

int main() {
  Calculator calc;  // 创建对象
  
  // 绑定成员函数：第一个参数是成员函数地址，第二个参数是对象（this指针）
  // 固定第二个参数为 2，第一个参数用 _1 占位
  auto multiplyBy2 = std::bind(&Calculator::multiply, &calc, std::placeholders::_1, 2);
  
  // 调用：只需要传入第一个参数
  std::cout << multiplyBy2(3) << std::endl;  // 等价于 calc.multiply(3, 2) → 输出 6
  std::cout << multiplyBy2(5) << std::endl;  // 等价于 calc.multiply(5, 2) → 输出 10
  return 0;
}
```

- 绑定成员函数时，第一个参数必须是 “成员函数地址”（`&Calculator::multiply`）；
- 第二个参数必须是 “对象指针”（`&calc`），用于指定 `this` 指针；
- 后续参数按成员函数的参数顺序排列（可以用占位符或固定值）。

3. 调整参数顺序

`std::bind` 可以改变参数的传入顺序，比如交换两个参数的位置：

```cpp
#include <functional>
#include <iostream>

// 输出 a - b
int subtract(int a, int b) {
  return a - b;
}

int main() {
  // 绑定 subtract，但交换参数顺序：_2 表示第一个传入的参数作为 b，_1 作为 a
  auto reverse_subtract = std::bind(subtract, std::placeholders::_2, std::placeholders::_1);
  
  std::cout << reverse_subtract(3, 5) << std::endl;  // 等价于 subtract(5, 3) → 输出 2
  return 0;
}
```

三、结合LSM的 RedisServer 代码理解

LSM的代码中，`std::bind` 用于绑定类的成员函数（`onConnection` 和 `onMessage`），适配 muduo 库的回调要求：

```cpp
// 绑定连接回调
server_.setConnectionCallback(
    std::bind(&RedisServer::onConnection, this, std::placeholders::_1)
);

// 绑定消息回调
server_.setMessageCallback(
    std::bind(&RedisServer::onMessage, this, std::placeholders::_1,
              std::placeholders::_2, std::placeholders::_3)
);
```

- muduo 库的 `setConnectionCallback` 要求传入一个 “接受 `const TcpConnectionPtr&` 参数的函数”；

- 你的 `onConnection` 是 `RedisServer` 的成员函数，需要 `this` 指针，且参数为 `const TcpConnectionPtr&`；

- ```
  std::bind(&RedisServer::onConnection, this, _1)
  ```

  完成了两件事：

  1. 将 `this` 与成员函数绑定（明确调用哪个对象的 `onConnection`）；
  2. 用 `_1` 占位，表示参数由 muduo 库在事件发生时传入（即客户端连接对象）。

这样绑定后，muduo 库就能在合适的时机（客户端连接 / 断开时）正确调用你的 `onConnection` 函数了。

四、`std::bind` 的核心价值

1. **参数适配**：让函数的参数数量、顺序与调用场景匹配（如库函数要求的回调格式）；
2. **延迟调用**：提前绑定部分参数，生成一个 “随时可调用” 的函数对象（比如保存到队列中， later 执行）；
3. **代码复用**：通过固定不同参数，从一个函数生成多个 “变体函数”（如从 `add` 生成 `add10`、`add100`）。

